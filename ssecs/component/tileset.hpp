#ifndef TILESET_HPP
#define TILESET_HPP

#include <cstddef>
#include <map>
#include <string>
#include <type_traits>
#include <vector>

#include <SDL_render.h>

#include "../../xml/pugixml.hpp"

#include "../config.hpp"

namespace ssecs::component
{
/**
 * @brief The TileSet class.
 * Represent the minimal tile handling.
 */
class TileSet
{
public:
    using size_type = std::size_t;
    using tile_type = SDL_Rect;
    using name_type = std::string;
    using texture_type = SDL_Texture;

    /**
     * @brief Load tile set properties from xml file.<br>
     * Where to get the template of xml file for tile set?<br>
     * Well, I suggest to use Tiled Map Editor. *(The version i used is 1.3.1)*
     * You can get it here: https://www.mapeditor.org/ <br>
     * Example of xml file that was generated by Tiled Map Editor:
     * @code
     * <?xml version="1.0" encoding="UTF-8"?>
     * <tileset version="1.2" tiledversion="1.3.1" name="tile" tilewidth="16" tileheight="16" tilecount="72"
     * columns="9">
     *  <tileoffset x="3" y="0"/>
     *  <image source="full tilemap.png" width="144" height="128"/>
     *  <tile id="0" type="decor">
     *      <properties>
     *          <property name="name" value="thing"/>
     *      </properties>
     *  </tile>
     *  <tile id="12" type="floor">
     *      <properties>
     *          <property name="name" value="rock"/>
     *      </properties>
     *  </tile>
     *  <tile id="30">
     *      <properties>
     *          <property name="name" value="chair"/>
     *      </properties>
     *  </tile>
     *  <tile id="31" type="floor"/>
     * </tileset>
     * @endcode
     * Several Parametrs did't use by this method, but it's easy to make your own tile set description.
     *
     * @param xml_doc Path to xml document.
     * @param texture Texture of tile sheet.
     */
    void Load(std::string_view xml_doc, texture_type *texture)
    {
        pugi::xml_document document;

        auto result = document.load_file(xml_doc.data());
        if (!result)
        {
            FAST_THROW(result.description());
        }

        auto tileset = document.child("tileset");
        m_name = tileset.attribute("name").value();
        m_tileWidth = std::stoi(tileset.attribute("tilewidth").value());
        m_tileHeight = std::stoi(tileset.attribute("tileheight").value());
        m_buffer.w = m_tileWidth;
        m_buffer.h = m_tileHeight;

        m_columns = std::stoi(tileset.attribute("columns").value());
        m_rows = std::stoi(tileset.attribute("tilecount").value()) / m_columns;

        m_texture = texture;

        {
            auto offset = tileset.child("tileoffset");
            if (offset)
            {
                m_offset.x = std::stoi(offset.attribute("x").value());
                m_offset.y = std::stoi(offset.attribute("y").value());
            }
        }
        {
            auto image = tileset.child("image");

            m_offset.w = std::stoi(image.attribute("width").value());
            m_offset.h = std::stoi(image.attribute("height").value());
        }
        {
            auto tiles = tileset.children("tile");
            for (auto it = tiles.begin(); it != tiles.end(); it++)
            {
                auto id = std::stoi(it->attribute("id").value());
                auto type = it->attribute("type");
                if (type)
                {
                    m_typedTiles.emplace(type.value(), std::stoi(it->attribute("id").value()));
                }
                auto properties = it->child("properties");
                if (properties)
                {
                    auto name = properties.first_child().attribute("name");
                    if (name)
                    {
                        m_namedTiles.emplace(name.value(), id);
                    }
                }
            }
        }
    }

    /**
     * @brief Return TileSet texture.
     * @return Texture if it exists, otherwise nullptr.
     */
    texture_type *Texture() const noexcept
    {
        return m_texture;
    }
    /**
     * @brief Return count of columns in current TileSet.
     * @return Num of columns.
     */
    size_type Columns() const noexcept
    {
        // return (m_offset.w - m_offset.x) / m_tileWidth;
        return m_columns;
    }

    /**
     * @brief Return count of rows in current TileSet.
     * @return Num of rows.
     */
    size_type Rows() const noexcept
    {
        // return (m_offset.h - m_offset.y) / m_tileHeight;
        return m_rows;
    }

    /**
     * @brief Return count of tiles in current TileSet.
     * @return Num of tiles.
     */
    size_type Count() const noexcept
    {
        return m_columns * m_rows;
    }

    /**
     * @brief Position of tile in current TileSet.
     * @param id Valid id.
     * @return Row and column pair.
     */
    std::pair<size_type, size_type> Position(const size_type id) const noexcept
    {
        SSECS_ASSERT(Valid(id));
        size_type row = id / Columns();
        size_type column = id - row * Columns();

        return std::make_pair(row, column);
    }

    /**
     * @brief Check if row and column exist in TileSet.
     * @param row Valid row type.
     * @param column Valid column type.
     * @return True if exist, otherwise false.
     */
    bool Valid(const size_type row, const size_type column) const noexcept
    {
        return row <= m_rows && column <= m_columns;
    }

    /**
     * @brief Check if tile is exist in TileSet.
     * @note This checking of tile is little bit complicated then other Valid's family methods.
     * @param tile Valid tile type.
     * @return True if exist, otherwise false.
     */
    bool Valid(const tile_type tile) const noexcept
    {
        bool size = (tile.w == m_tileWidth && tile.h == m_tileHeight);
        bool in_range = (tile.x > 0 && tile.x + tile.w < m_offset.w) && (tile.y > 0 && tile.y + tile.h < m_offset.h);
        bool integral = std::is_integral_v<decltype((tile.x - m_offset.x) / m_tileWidth)> &&
                        std::is_integral_v<decltype((tile.y - m_offset.y) / m_tileHeight)>;
        return size && in_range && integral;
    }

    /**
     * @brief Check if id exist in TileSet.
     * @param row Valid id type.
     * @return True if exist, otherwise false.
     */
    bool Valid(const size_type id) const noexcept
    {
        return id < Count();
    }

    /**
     * @brief Generate tile with internal params.
     * @param row Valid row num.
     * @param column Valid column num.
     * @warning Typing not valid's param returned not valid Tile.
     * Include assert for this situation.
     * @return Desired tile.
     */
    const tile_type &Tile(const size_type row, const size_type column) noexcept
    {
        SSECS_ASSERT(Valid(row, column));
        m_buffer.x = m_offset.x + static_cast<int>(column) * m_tileWidth;
        m_buffer.y = m_offset.y + static_cast<int>(row) * m_tileHeight;
        return m_buffer;
    }

    /**
     * @brief Generate tile with internal params.
     * @param id Valid id num.
     * @warning Typing not valid's param returned not valid Tile.
     * Include assert for this situation.
     * @return Desired tile.
     */
    const tile_type &operator[](const size_type id) noexcept
    {
        auto [row, column] = Position(id);
        return Tile(row, column);
    }

    /**
     * @brief Generate tile with internal params.
     * @param name Valid tile name.
     * @warning Typing not valid's param returned not valid Tile.
     * Include assert for this situation.
     * @return Desired tile.
     */
    tile_type operator[](std::string_view name)
    {
        return (*this)[m_namedTiles.at(name.data())];
    }

    /**
     * @brief Check if name exist in a map.
     * @param name Map key.
     * @return True if exist, false otherwise.
     */
    bool HasName(std::string_view name) const
    {
        return m_namedTiles.find(name.data()) != m_namedTiles.end();
    }
    /**
     * @brief Check if type exist in a map.
     * @param type Map key.
     * @return True if exist, false otherwise.
     */
    bool HasType(std::string_view type) const
    {
        return m_typedTiles.find(type.data()) != m_typedTiles.end();
    }
    /**
     * @brief Return iterator for id's of desired type.
     * @param Type Tile's type.
     * @return Iterator.
     */
    decltype(auto) operator()(std::string_view type) const
    {
        return m_typedTiles.equal_range(type.data());
    }

    std::vector<SDL_Rect> GetTypeFamily(std::string_view type)
    {
        std::vector<SDL_Rect> vec;

        auto it = (*this)(type);
        vec.reserve(std::distance(it.first, it.second));
        for (auto begin = it.first; begin != it.second; ++begin)
        {
            vec.push_back((*this)[begin->second]);
        }
        return vec;
    }

    int TileWidth() const noexcept
    {
        return m_tileWidth;
    }
    int TileHeight() const noexcept
    {
        return m_tileHeight;
    }

private:
    SDL_Texture *m_texture = nullptr;
    SDL_Rect m_offset{};
    SDL_Rect m_buffer{};

    int m_tileWidth{};
    int m_tileHeight{};
    size_type m_rows;
    size_type m_columns;

    std::string m_name{};

    std::map<name_type, size_type> m_namedTiles;
    std::multimap<name_type, size_type> m_typedTiles;
};
} // namespace ssecs::component
#endif // TILESET_HPP
