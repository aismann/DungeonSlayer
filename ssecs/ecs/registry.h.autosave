#ifndef REGISTRY_H
#define REGISTRY_H


#include <vector>
#include <algorithm>

#include "storage.h"
#include "family.h"
#include "component.h"

namespace ssecs::ecs    
{

template<typename Entity>
class registry
{
    using component_family = family<struct internal_registry_component_family>;    
    using component_pool = storage<Entity, std::unique_ptr<base_component>>;
    
    template<typename Component>
    struct pool_handler : storage<Entity, Component>
    {
        template<typename ...cArgs>
        decltype(auto) assign([[maybe_unused]] registry& owner, const Entity entity, cArgs&&... args)
        {
            return storage<Entity,Component>::insert(entity,std::forward<cArgs>(args)...);
        }
        void remove([[maybe_unused]] registry& owner, const Entity entity)
        {
            storage<Entity,Component>::remove(entity);
        }
        template<typename ...cArgs>
        decltype(auto) replace([[maybe_unused]] registry& owner, const Entity entity, cArgs&&... args)
        {
            Component component{std::forward<cArgs>(args)...};
            return (storage<Entity,Component>::get(entity) = std::move(component));
        }
        
    };
    template<typename Component>
    using pool_type = pool_handler<std::decay_t<Component>>;
    
    struct pool_data 
    {
        std::unique_ptr<tools::sparse_set<Entity>> pool;

        ENTT_ID_TYPE runtime_type;
    };
    
private:
    
    

public:
    registry() = default;
    registry(std::size_t allocate_size)
    {
        m_destroyed.resize(allocate_size);
        
        for(std::size_t i=0; i < allocate_size; m_destroyed[i] = i++ );
    }
    ~registry() = default;
    
    Entity& create()
    {
        if(m_destroyed.size == 0)
        {
            m_destroyed.resize(m_entities.size());
            Entity id = m_entities.size();
            for(std::size_t i=0; i < m_destroyed.size();i++)
            {
                m_destroyed[i] = id++;
            }
                
        }
        
        m_entities.push_back(m_destroyed.back());
        
    }
    void destroy(const Entity entity)
    {
        m_entities.
    }
    
    template<typename Component>
    static component type() ENTT_NOEXCEPT 
    {
            return component{runtime_type<Component, component_family>()};
        }
    


private:
    std::vector<Entity> m_entities {};
    std::vector<Entity> m_destroyed {};

    std::vector<std::unique_ptr<tools::sparce_set<Entity>>> m_pools;
};
}

#endif // REGISTRY_H
